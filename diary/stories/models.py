from django.conf import settings
from django.db import models
from django.utils.translation import gettext as _
from django.utils.safestring import SafeString

from martor.models import MartorField

from stories.utils import markdownify

# Create your models here.

class StoryQuerySet(models.QuerySet):
    pass


class StoryManager(models.Manager):
    def get_queryset(self):
        return StoryQuerySet(self.model, using=self._db)

    def recent(self):
        """ Order the list of visible Entries by their published date (descending) """
        return self.published()

    def published(self, **kwargs):
        """ Return a QS of all published articles that have not been hidden """
        return (self.filter(hidden_at=None, **kwargs)
                .exclude(published_at__isnull=True)
                .order_by('-published_at'))

    def by_author(self, author):
        """ Return the recent list of stories by this author """
        return self.recent().filter(author=author)

    def inspired(self, inspiration):
        """ Return a queryset of the list of stories inspired by this story """
        return self.published(inspired_by=inspiration)

    def next_chapter(self, story):
        """ A story by the same author that comes after this story is tne
             next_chapter of this story """
        return self.published(preceded_by=story, author=story.author)

    def drafts(self, user):
        """ Return a queryset of drafts written by this user so they can finish them
              and get them published. """
        return self.filter(published_at__isnull=True, author__user=user)


class Story(models.Model):
    """ Holds a single story's content and relationships to other stories """
    author = models.ForeignKey('authors.Author', verbose_name=_("Pseudonym"),
                               on_delete=models.PROTECT)
    title = models.CharField(max_length=64, null=False, blank=False)
    tagline = models.CharField(max_length=64, blank=True)
    text = MartorField(null=False, blank=False)

    # The preview used in the list view.  Autogenerated with possible override by the author
    teaser = models.TextField(blank=False, null=True, max_length=140)

    # The story behind the story.  (No, this should probably NOT be a separate story.)
    about = MartorField(blank=True)

    # Source of this story (if it was copied from somewhere else)
    source = models.URLField(blank=True)

    # This is the license under which the story is controlled
    license = models.ForeignKey('licenses.license', null=True, blank=True, on_delete=models.PROTECT)

    # This was published by the author on this date (None = draft/private)
    published_at = models.DateTimeField(default=None, null=True, blank=True, db_index=True)

    # This was hidden by an admin for questionable content
    hidden_at = models.DateTimeField(default=None, null=True, blank=True)

    # The author is writing this story because they were inspired_by the indicated story
    inspired_by = models.ForeignKey('self', default=None, null=True, blank=True,
                                    on_delete=models.PROTECT)

    # This story follows another story (like inspired_by, but more like a chapter2 situation)
    preceded_by = models.ForeignKey('self', default=None, null=True, blank=True,
                                    on_delete=models.PROTECT, related_name='previous_chapter')


    # Language the story is written in (so we can tell the browser in the HTTP headers and trigger
    #   translation prompting)
    language = models.CharField(_('language'),
                                max_length=5,
                                choices=settings.LANGUAGES,
                                default=settings.LANGUAGE_CODE[:2],
                                help_text=_('Story language.'))

    class Meta:
        verbose_name_plural = "stories"


    objects = StoryManager()

    def __str__(self):
        return self.full_title()

    def full_title(self):
        """ """
        return '%s: %s' % (self.title, self.tagline)

    def read_time(self):
        return _("Short read")

    def html(self):
        """ Return the html version of the markdown.  Wraps it as a SafeString so it will
              display without being escaped.  This should probably be done and cached somewhere
              and let this method do a lookup for the cached version.  An alternative would be to
              double the storage in the DB but that could mean having to update the whole  DB if we
              fix something about martor.  Storing this in a memcached instance would probably
              be better """
        # TODO: Store the results in memcached for speed
        return SafeString(markdownify(self.text))

    def next_chapter_id(self):
        """ The id of the story (with preceeded_by_id == self.id) by the same author
              is the next_chapter of this story. This is used by the serializers"""
        if not hasattr(self, '_next_chapter_id'):
            self._next_chapter_id = Story.objects.next_chapter(story=self).values_list('id', flat=True).first()
        return self._next_chapter_id

    def next_chapter(self):
        """ A story by the same author that comes after this story is tne
             next_chapter of this story.  This is used when formatting the story with a template. """
        if not hasattr(self, '_next_chapter'):
            self._next_chapter = Story.objects.next_chapter(story=self).first()
        return self._next_chapter

    def refresh_from_db(self, using=None, fields=None):
        """ Clear the extra pseudo fields we have added for next_chapter and next_chapter_id since Django
              doesn't know about them """
        if hasattr(self, '_next_chapter') and (not fields or '_next_chapter' in fields):
            del self._next_chapter
        if hasattr(self, '_next_chapter_id') and (not fields or '_next_chapter_id' in fields):
            del self._next_chapter_id

        return super(Story, self).refresh_from_db(using, fields)


class Flag(models.Model):
    """ When an entry is flagged, it gets one of these records"""
    HATE_SPEECH = 1
    SPAM = 2
    EXPLICIT = 3

    FLAG_CHOICES = (
        (HATE_SPEECH, _("Hate Speech")),
        (SPAM, _("Spam")),
        (EXPLICIT, _("Sexually Explicit")),
    )
    user = models.ForeignKey(settings.AUTH_USER_MODEL, null=True, on_delete=models.PROTECT)
    entry = models.ForeignKey(Story, null=False, db_index=True, on_delete=models.PROTECT)
    flagged_at = models.DateTimeField(auto_now_add=True, null=False)
    reason = models.IntegerField(choices=FLAG_CHOICES, default=0)


class UpVotes(models.Model):
    """ When an entry is UpVoted, it gets one of these records"""
    user = models.ForeignKey(settings.AUTH_USER_MODEL, null=True, on_delete=models.PROTECT)
    entry = models.ForeignKey(Story, null=False, db_index=True, on_delete=models.PROTECT)
    voted_at = models.DateTimeField(auto_now_add=True, null=False)


class DownVotes(models.Model):
    """ When an entry is DownVoted, it gets one of these records"""
    user = models.ForeignKey(settings.AUTH_USER_MODEL, null=True, on_delete=models.PROTECT)
    entry = models.ForeignKey(Story, null=False, db_index=True, on_delete=models.PROTECT)
    voted_at = models.DateTimeField(auto_now_add=True, null=False)
